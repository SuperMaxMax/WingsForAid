import  numpy as np
from    parameters import *
import  matplotlib.pyplot as plt

def metertofeet(meter):
    feet = meter*3.2808399
    return feet

# W/S and W/P diagrams
# drag polar
def dragpolar(CL, CD0, e, A):
    CD = CD0 + (CL**2/(np.pi*A*e))
    return CD

def stallWS(V, rho, CL_max):
    WoS = 1/2 * rho * V**2 * CL_max
    return WoS

def TOP_calc(WS, sigma, CL_TO, BHP, W_TO):
    TOP = WS/(sigma*CL_TO*(BHP/W_TO))
    return TOP

def altitude_effects(h, Lambda, R, g, T0, rho0, BHP0):
    rho     = rho0*(1+ ((Lambda*h)/T0))**(-((g/(R*Lambda))+1))
    sigma   = rho/rho0
    BHP     = BHP0*(sigma)**(3/4)
    return rho, sigma, BHP

def WP_WSdiagrams(h, plot=True):
    # find atmospheric properties and power at altitude according to ISA
    rho, sigma, BHP = altitude_effects(h, Lambda, R, g0, T0, rho0, P_max)
    
    # define a W/S and W/P array to make graphs later on
    WS  = np.arange(100.0, 2201.0, 1.0)
    WP  = np.arange(0.0, 1.501, (1.5/len(WS)))
    
    # sizing for stall, maximum W/S values based on a CL max and a Vstall of 50 kts for dropping
    WS_stall = np.empty(0)
    for i in range(len(CL_max_clean)):
        WS_stall_max = stallWS(V_s_min, rho, CL_max_clean[i])
        WS_stall_max = np.full(len(WP), WS_stall_max)
        WS_stall_max = np.vstack((WS_stall_max, WP))
        if i == 0:
            WS_stall = WS_stall_max
        else:
            WS_stall = np.vstack((WS_stall, WS_stall_max))
    # Take off sizing using Take-off parameter (TOP) 
    TOP_req = 250                                       #read from graph of ADSEE 1 slides, slide 29 lecture 3
    WP_TO   = np.empty(0)
    for j in range(len(CL_TO)):
        WP_takeoff  = (TOP_req/WS)*CL_TO[j]*sigma
        WP_takeoff  = np.vstack((WP_takeoff, WS))
        if j == 0:
            WP_TO   = WP_takeoff
        else:
            WP_TO   = np.vstack((WP_TO, WP_takeoff))
    
    # Landing W/S
    WS_landing = np.empty(0)
    for k in range(len(CL_LDG)): 
        WS_ldg = (CL_LDG[i]*rho*(LDG_dist/0.5915))/(2*f)
        WS_ldg = np.full(len(WP), WS_ldg)
        WS_ldg = np.vstack((WS_ldg, WP))
        if k == 0:
            WS_landing = WS_ldg
        else:
            WS_landing = np.vstack((WS_landing, WS_ldg))
    # W/P cruise
    rho_cruise, sigma_cruise, BHP_cruise = altitude_effects(h_cruise, Lambda, R, g0, T0, rho0, P_max)
    WP_cruise   = (power_setting/cruise_frac)*eta_p*sigma**(3/4)*(((CD0*1/2*rho_cruise*V_cruise**3)/(WS*cruise_frac))+(WS*(1/(np.pi*A*e*rho_cruise*V_cruise))))**(-1)
    WP_cruise   = np.vstack((WP_cruise, WS))

    #Climb performance
    climb_rate  = (8.3/100)*V_climb                      #8.3% climb gradient found in CS23
    WP_Climb    = eta_p/(climb_rate+((np.sqrt(WS)*np.sqrt(2/rho0))/(1.345*(A*e)**(3/4)/CD0**(1/4))))
    WP_Climb    = np.vstack((WP_Climb, WS))
    
    #Evaluating if stall WS or landing WS is limiting
    stall_limit     = 0
    landing_limit   = 0
    plot_stall_WS   = False
    plot_both_WS    = False
    plot_LDG_WS     = False

    for z in range(int(len(WS_stall)/2)):
        if WS_stall[2*z][0] < WS_landing[2*z][0]:
            stall_limit += 1
        else:
            landing_limit += 1
    if stall_limit > landing_limit:
        plot_stall_WS = True
    elif stall_limit == landing_limit:
        plot_both_WS = True
    else:
        plot_LDG_WS = True

    #plotting
    if plot:
        for i in range(int(len(WP_TO)/2)):
            lab = "Take-off, CL TO = " + str(np.round(CL_TO[i], decimals=2))
            plt.plot(WP_TO[2*i+1], WP_TO[2*i], label=lab)
        if plot_stall_WS:
            for k in range(int(len(WS_stall)/2)):
                plt.plot(WS_stall[2*k], WS_stall[2*k+1])
        if plot_both_WS:
            for j in range(int(len(WS_ldg)/2)):
                plt.plot(WS_ldg[2*j], WS_ldg[2*j+1])
            for k in range(int(len(WS_stall)/2)):
                plt.plot(WS_stall[2*k], WS_stall[2*k+1])
        if plot_LDG_WS:
            for j in range(int(len(WS_ldg)/2)):
                plt.plot(WS_ldg[2*j], WS_ldg[2*j+1])
        plt.plot(WP_cruise[1], WP_cruise[0], label="Cruise requirement")
        plt.plot(WP_Climb[1], WP_Climb[0], label="Climb requirement")
        plt.xlabel("W/S [N/m^2]")
        plt.ylabel("W/P [N/W]")
        plt.ylim((0, 1.5))
        plt.legend(loc='upper right')
        plt.show()
    # give the design point, optimised to the top right of the diagram
    # WP_selected = float(input("Please give the W/P of the design point: "))
    # WS_selected = float(input("Please give the W/S of the design point: "))
    return 

#W/P and W/S are now known, define wing surface area
WPWS = WP_WSdiagrams(0, plot=True)

    









