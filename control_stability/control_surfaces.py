import numpy as np
import sys
import matplotlib.pyplot as plt
from matplotlib import patheffects
from scipy.integrate import quad
from scipy.optimize import fsolve
from math import *

sys.path.append('..')

from parameters import atmosphere
atm      = atmosphere()


def Chordlength(y, aircraft):
    return aircraft.rootchord * (1 - ((1-aircraft.taper) / (aircraft.b / 2)) * y)

def aileron_design(aircraft):  # Using Aircraft design: A Systems Engineering Approach, Ch 12.4
    ''' '''
    '''Roll performance requirments'''
    phi_des_list = [30* (pi/180), 45* (pi/180), 60* (pi/180)]   # Roll requirement
    t_lim_list = [1.3, 1.7, 1.3]  # Max time available to complete the roll requirement
    ystart_a_list = []
    t = 3  # starting time

    for i in range(0, 3, 1):
        '''Design parameters'''
        t =3
        iteration_value = True
        phi_des = phi_des_list[i]
        t_lim = t_lim_list[i]
        delta_a_max = 20 * (pi/180) # max aileron deflection
        delta_a_design = delta_a_max * 0.95
        tau = 0.47  # factor based on the fraction of chord that is the aileron
        Ixx = aircraft.Ixx  # mass moment of inertia x-axis [kg m^2]
        ystart_a = 0.98 * (aircraft.b/2 + aircraft.w_out/2)  # staring location of aileron
        yend_a = 0.98 * (aircraft.b/2 + aircraft.w_out/2)  # end location of aileron
        y_d = 0.4 * (aircraft.b/2 + aircraft.w_out/2)  # average distance between the centre of gravity of the aircraft and the centre of drag [m] 
        Cdr = 0.9  # aircraft drag coefficient in rolling motion

        if iteration_value:
            while t > t_lim:
                if ystart_a > 0:
                    ystart_a = ystart_a - 0.01*(aircraft.b/2 + aircraft.w_out/2)
                else:
                    print("Aileron size required for roll performance exceeds wing size")
                    break
                # v Roll moment calculation v
                C_l_delta_a = (2*aircraft.CLa_w_cruise* tau *aircraft.rootchord/(aircraft.Sw * (aircraft.b + aircraft.w_out))) * ((yend_a**2/2 + 2/3 * ((aircraft.taper - 1)/(aircraft.b + aircraft.w_out)) * yend_a**3)- (ystart_a**2/2 + 2/3 * ((aircraft.taper - 1)/(aircraft.b + aircraft.w_out)) * ystart_a**3))
                C_l_max = C_l_delta_a * delta_a_design
                aircraft.Clmax_ail = C_l_max
                L_a = 1/2 * atm.rho0 * (aircraft.V_s_min * 1.3)**2 * aircraft.Sw * ((yend_a + ystart_a)/2) * C_l_max  # Rolling moment generated by aileron [Nm]
                
                # v Steady State Rollrate v
                Pss = sqrt(2*L_a/((aircraft.Sw + aircraft.Sh_S * aircraft.Sw + aircraft.Sv_S * aircraft.Sw) * Cdr * y_d**3))
            
                phi_1 = Ixx/(atm.rho0 * y_d**3* Cdr * (aircraft.Sw + aircraft.Sh_S * aircraft.Sw + aircraft.Sv_S * aircraft.Sw)) * np.log(Pss**2)

                P_roll_rate = Pss**2/(2*phi_1)

                t = sqrt(2*phi_des/P_roll_rate)
                print(f"{phi_des}: t: {t}")
            ystart_a_list.append(ystart_a)
      
            aircraft.ystart_ail = min(ystart_a_list) - aircraft.w_out/2  # to account for wing starting at fuselage border
            aircraft.yend_ail = 0.98*(aircraft.b/2 +aircraft.w_out/2) - aircraft.w_out/2  # to account for wing starting at fuselage border

            aircraft.S_aileron = (aircraft.yend_ail - aircraft.ystart_ail) * (Chordlength(aircraft.ystart_ail, aircraft) + Chordlength(aircraft.yend_ail, aircraft))/2
        else:
                C_l_delta_a = (2*aircraft.CLa_w_cruise* tau *aircraft.rootchord/(aircraft.Sw * (aircraft.b + aircraft.w_out))) * ((yend_a**2/2 + 2/3 * ((aircraft.taper - 1)/(aircraft.b + aircraft.w_out)) * yend_a**3)- (ystart_a**2/2 + 2/3 * ((aircraft.taper - 1)/(aircraft.b + aircraft.w_out)) * ystart_a**3))
                C_l_max = C_l_delta_a * delta_a_design
                aircraft.Clmax_ail = C_l_max
                L_a = 1/2 * atm.rho0 * (aircraft.V_s_min * 1.3)**2 * aircraft.Sw * ((yend_a + ystart_a)/2) * C_l_max  # Rolling moment generated by aileron [Nm]
                
                # v Steady State Rollrate v
                Pss = sqrt(2*L_a/((aircraft.Sw + aircraft.Sh_S * aircraft.Sw + aircraft.Sv_S * aircraft.Sw) * Cdr * y_d**3))
            
                phi_1 = Ixx/(atm.rho0 * y_d**3* Cdr * (aircraft.Sw + aircraft.Sh_S * aircraft.Sw + aircraft.Sv_S * aircraft.Sw)) * np.log(Pss**2)

                P_roll_rate = Pss**2/(2*phi_1)

                t = sqrt(2*phi_des/P_roll_rate)
                aircraft.ystart_ail = ystart_a - aircraft.w_out/2  # to account for wing starting at fuselage border
                aircraft.yend_ail = 0.98*(aircraft.b/2 +aircraft.w_out/2) - aircraft.w_out/2  # to account for wing starting at fuselage border

    delta_L = L_a/2 /((aircraft.yend_ail + aircraft.ystart_ail + aircraft.w_out)/2 * (aircraft.b/2 + aircraft.w_out/2))

def elevator_design(aircraft, plot):
    
    # C_L_c = 2 * aircraft.W_TO *atm.g0/(aircraft.rho * aircraft.V_cruise**2 * aircraft.Sw)
    # C_L_TO = C_L_c + aircraft.CS_dCLmax_TO
    # C_D_TO = aircraft.CD0 + 1/(aircraft.e * aircraft.A * np.pi)*C_L_TO**2
    # D_TO = 1/2 * atm.rho0 * C_D_TO * aircraft.Vs_min**2 * aircraft.Sw 
    # L_TO = 1/2 * atm.rho0 * C_L_TO * aircraft.Vs_min**2 * aircraft.Sw 
    # M_ac_wf = 1/2*atm.rho0 * aircraft.Cm_ac_w * aircraft.Vs_min**2 * aircraft.Sw * aircraft.MAC_length

    
    aircraft.L_h = 0.5 * 0.7 * aircraft.CL_h * (aircraft.V_cruise)**2 * aircraft.Sh_S * aircraft.Sw
    
    T= 2800 
    z_position_T = -(aircraft.ST_z_prop + aircraft.prop_radius - aircraft.ST_z_cg_ground)

    eta_h = 0.96
    V_range = np.arange(aircraft.V_s_min, aircraft.V_cruise*1.4, 2)
    
    # color_r = ['black', 'steelblue']
    # e = 0
    # for X_cg in [aircraft.X_cg_fwd, aircraft.X_cg_aft]:
    #     delta_eq_req_range = []
    #     for V in V_range:
    #         l_h = aircraft.l_f - aircraft.l_fus_tail_cone + aircraft.l_f_boom - 3/4 * aircraft.AE_rootchord_h - (aircraft.X_LEMAC+ X_cg*aircraft.MAC_length)
    #         C_L1 = 2 * aircraft.W_TO * aircraft.g0 /(aircraft.rho_TO* V**2*aircraft.Sw)
    #         tail_volume = l_h/aircraft.MAC_length * aircraft.Sh_S

    #         C_L_delta_e = aircraft.CLa_Ah_cruise * eta_h * aircraft.Sh_S * 1
    #         C_m_delta_e = -aircraft.CLa_Ah_cruise *eta_h * tail_volume * 1

    #         delta_e_req = - ((T*z_position_T/(1/2 * aircraft.rho_TO * V**2 * aircraft.Sw * aircraft.MAC_length) + aircraft.af_cm0) * aircraft.CLa_w_cruise + (C_L1 - aircraft.af_Cl0)*aircraft.C_m_alpha)/(aircraft.CLa_w_cruise*C_m_delta_e - aircraft.C_m_alpha*C_L_delta_e)
    #         delta_eq_req_range.append(delta_e_req*180/np.pi)
    #     plt.scatter(V_range, delta_eq_req_range, marker='x', color=color_r[e])#(color_r[e] for e in range(len(color_r))))
    #     e += 1
    X_cg = np.array([aircraft.X_cg_fwd, aircraft.X_cg_aft])
    C_L_delta_e = aircraft.CLa_Ah_cruise * eta_h * aircraft.Sh_S * 1
    C_L1 = 2 * aircraft.W_TO * aircraft.g0 /(aircraft.rho_TO * (V_range**2)*aircraft.Sw)

    #Calculate for both cg positions, [fwd, aft]
    l_h = aircraft.l_f - aircraft.l_fus_tail_cone + aircraft.l_f_boom - 3/4 * aircraft.AE_rootchord_h - (aircraft.X_LEMAC+ X_cg*aircraft.MAC_length)
    tail_volume = l_h / aircraft.MAC_length * aircraft.Sh_S
    C_m_delta_e = -aircraft.CLa_Ah_cruise *eta_h * tail_volume * 1

    delta_e_req_fwd = (-((T*z_position_T/(1/2 * aircraft.rho_TO * (V_range**2) * aircraft.Sw * aircraft.MAC_length) + aircraft.af_cm0) * aircraft.CLa_w_cruise + (C_L1 - aircraft.af_Cl0)*aircraft.C_m_alpha)/(aircraft.CLa_w_cruise*C_m_delta_e[0] - aircraft.C_m_alpha*C_L_delta_e)) * (180/np.pi)
    delta_e_req_aft = (-((T*z_position_T/(1/2 * aircraft.rho_TO * (V_range**2) * aircraft.Sw * aircraft.MAC_length) + aircraft.af_cm0) * aircraft.CLa_w_cruise + (C_L1 - aircraft.af_Cl0)*aircraft.C_m_alpha)/(aircraft.CLa_w_cruise*C_m_delta_e[1] - aircraft.C_m_alpha*C_L_delta_e)) * (180/np.pi)

    if plot:
        plt.figure(figsize=(8,8))
        plt.scatter(V_range, delta_e_req_fwd, marker='x', color='black')
        plt.scatter(V_range, delta_e_req_aft, marker='x', color='steelblue')

        plt.xlabel(r"V [m/s]")
        plt.ylabel(r"$\delta_E$ [deg]")

        plt.axvline(x=aircraft.V_cruise, color='red', linestyle='--')
        plt.text(aircraft.V_cruise - 2.5, min(delta_e_req_aft), r'$V_{cruise}$', rotation=90, color='red')

        plt.grid()
        plt.show(block=True)

def rudder_design(aircraft):#, tau_r):
    
    V_w = 20 * (0.51444444444) # [m/s] side wind

    V_t = sqrt((1.3 * aircraft.V_s_min)**2 + V_w**2) # [m/s] total speed
    S_s = 1.02 * (aircraft.l_f * aircraft.h_out + aircraft.Sv_S * aircraft.Sw)

    x_ca = aircraft.l_f * aircraft.h_out * aircraft.X_FCG + aircraft.AE_Sv * aircraft.AE_l_v
    d_ca = x_ca - aircraft.x_cg_position_aft

    C_d_y = 0.6 # Assumption

    F_w = 0.5 * atm.rho0 * C_d_y * V_w**2 * S_s
    # print(f"F_w:{F_w}")
    angle_beta = np.arctan(V_w/(1.3 * aircraft.V_s_min))

    C_L_alpha_v = 3
    dsigma_dalpha = 0 
    eta_v = 0.96
    
    
    vertical_tail_volume = aircraft.AE_l_v*aircraft.AE_Sv/(aircraft.b*aircraft.Sw)

    C_n_beta = 0.75 * C_L_alpha_v * (1 - dsigma_dalpha) * eta_v * vertical_tail_volume
    C_y_beta = -1.35 * C_L_alpha_v * (1 - dsigma_dalpha) * eta_v * aircraft.Sv_S

    # aircraft.C_r_C_v = 0.4  # Aircraft design, table 12.12
    tau_r = 0.6  # Update this if above variable changes

    C_Y_delta_r = C_L_alpha_v * eta_v * tau_r * 1 * aircraft.Sv_S 
    C_n_delta_r = -C_L_alpha_v * vertical_tail_volume * eta_v * tau_r * 1

    # print("beta", C_n_beta)
    # print("beta", C_y_beta)
    # print("deltar", C_Y_delta_r)
    # print("deltar", C_n_delta_r)
    # Define the equations
    
    def equations(x):
        delta_r, sigma = x
        equation1 = 0.5 * atm.rho0 * V_t**2 * aircraft.Sw * aircraft.b * (C_n_beta*(angle_beta - sigma) + C_n_delta_r * delta_r) + F_w * cos(sigma) * d_ca
        equation2 = 0.5 * atm.rho0 * V_w**2 * S_s * C_d_y - 0.5*atm.rho0 * V_t**2 * aircraft.Sw * (C_y_beta*(angle_beta-sigma)+C_Y_delta_r*delta_r)
        return [equation1, equation2]
    # Solve the system of equations
    initial_guess = [1, 1]
    solution = fsolve(equations, initial_guess)

    # Extract the values
    delta_r_value = solution[0]
    sigma_value = solution[1]
    
    aircraft.delta_r_value = delta_r_value*(180/np.pi)

    if (delta_r_value*180/pi) > 30:
        print(f"\nRequired rudder deflection ({round(delta_r_value*180/np.pi, 3)} degrees) exceeds maximum rudder deflection (30 degrees)\n")

    #aircraft.S_r = aircraft.C_r_C_v * aircraft.C_v * aircraft.AE_b_v

def rudder_iteration(aircraft, plot):
    delta_r_value_array = []
    c_array = np.arange(0.10, 0.75, 0.05)
    tau_array = [0.27, 0.35, 0.41, 0.47, 0.52, 0.56, 0.6, 0.64, 0.68, 0.71, 0.74, 0.77, 0.8]
    for i in tau_array:
        tau_r = i
        rudder_design(aircraft)#, tau_r)

        delta_r_value_array.append(aircraft.delta_r_value)

    if plot:
        plt.figure()
        plt.scatter(c_array, delta_r_value_array, marker='x', color='black')
        plt.axhline(y=30, color= 'red')
        plt.text(0.6, 30.5, r"$\delta_{r_{max}}$", rotation=0, color='red')
        plt.axhline(y=27, color= 'darkorange')
        plt.text(0.6, 27.5, r"$\delta_{r_{max}}$ + margin", rotation=0, color='red')

        index = np.where(np.array(delta_r_value_array) < 27)[0][0]
        plt.scatter(c_array[index], delta_r_value_array[index], color='r')

        plt.xlabel(r"$\frac{C_r}{C_v}$")
        plt.ylabel(r"$\delta_{r_{max}}$ [deg]")
        plt.show(block=True)
    
def main_control_surface(aircraft, plot):
    aileron_design(aircraft)
    # rudder_iteration(aircraft, plot)
    rudder_design(aircraft)
    elevator_design(aircraft, plot)


