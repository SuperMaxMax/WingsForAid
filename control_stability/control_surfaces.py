import numpy as np
import sys
import matplotlib.pyplot as plt
from matplotlib import patheffects
from scipy.integrate import quad
from scipy.optimize import fsolve
from math import *

sys.path.append('..')

from parameters import atmosphere
atm      = atmosphere()


def Chordlength(y, aircraft):
    return aircraft.rootchord * (1 - ((1-aircraft.taper) / (aircraft.b / 2)) * y)

def aileron_design(aircraft):  # Using Aircraft design: A Systems Engineering Approach, Ch 12.4
    ''' '''
    '''Roll performance requirments'''
    phi_des_list = [30* (pi/180), 45* (pi/180), 60* (pi/180)]   # Roll requirement
    t_lim_list = [1.3, 1.7, 1.3]  # Max time available to complete the roll requirement
    ystart_a_list = []
    t = 3  # starting time

    for i in range(0, 3, 1):
        '''Design parameters'''
        phi_des = phi_des_list[i]
        t_lim = t_lim_list[i]
        delta_a_max = 20 * (pi/180) # max aileron deflection
        tau = 0.41  # factor based on the fraction of chord that is the aileron
        Ixx = 1400  # mass moment of inertia x-axis [kg m^2] TODO Update value 
        ystart_a = 0.95 * (aircraft.b/2 + aircraft.w_out/2)  # staring location of aileron
        yend_a = 0.95 * (aircraft.b/2 + aircraft.w_out/2)  # end location of aileron
        y_d = 0.4 * (aircraft.b/2 + aircraft.w_out/2)  # average distance between the centre of gravity of the aircraft and the centre of drag [m] 
        Cdr = 0.9  # aircraft drag coefficient in rolling motion

        while t > t_lim:
            ystart_a = ystart_a - 0.01*(aircraft.b/2 + aircraft.w_out/2)

            # v Roll moment calculation v
            C_l_delta_a = (2*aircraft.CLa_w_cruise* tau *aircraft.rootchord/(aircraft.Sw * (aircraft.b + aircraft.w_out))) * ((yend_a**2/2 + 2/3 * ((aircraft.taper - 1)/(aircraft.b + aircraft.w_out)) * yend_a**3)- (ystart_a**2/2 + 2/3 * ((aircraft.taper - 1)/(aircraft.b + aircraft.w_out)) * ystart_a**3))
            C_l_max = C_l_delta_a * delta_a_max
            L_a = 1/2 * atm.rho0 * (aircraft.V_s_min * 1.3)**2 * aircraft.Sw * ((yend_a + ystart_a)/2) * C_l_max  # Rolling moment generated by ailerons [Nm]
            
            # v Steady State Rollrate v
            Pss = sqrt(2*L_a/((aircraft.Sw + aircraft.AE_Sh_S * aircraft.Sw + aircraft.AE_Sv_S * aircraft.Sw) * Cdr * y_d**3))
        
            phi_1 = Ixx/(atm.rho0 * y_d**3* Cdr * (aircraft.Sw + aircraft.AE_Sh_S * aircraft.Sw + aircraft.AE_Sv_S * aircraft.Sw)) * np.log(Pss**2)

            P_roll_rate = Pss**2/(2*phi_1)

            t = sqrt(2*phi_des/P_roll_rate)
        ystart_a_list.append(ystart_a)
      
    aircraft.ystart_ail = min(ystart_a_list) - aircraft.w_out/2  # to account for wing starting at fuselage border
    aircraft.yend_ail = 0.95*(aircraft.b/2 +aircraft.w_out/2) - aircraft.w_out/2  # to account for wing starting at fuselage border

    aircraft.S_aileron = (aircraft.yend_ail - aircraft.ystart_ail) * (Chordlength(aircraft.ystart_ail, aircraft) + Chordlength(aircraft.yend_ail, aircraft))/2

    delta_L = L_a/2 /((aircraft.yend_ail + aircraft.ystart_ail + aircraft.w_out)/2 * (aircraft.b/2 + aircraft.w_out/2))

def elevator_design(aircraft):
    
    # C_L_c = 2 * aircraft.W_TO *atm.g0/(aircraft.rho * aircraft.V_cruise**2 * aircraft.Sw)
    # C_L_TO = C_L_c + aircraft.CS_dCLmax_TO
    # C_D_TO = aircraft.CD0 + 1/(aircraft.e * aircraft.A * np.pi)*C_L_TO**2
    # D_TO = 1/2 * atm.rho0 * C_D_TO * aircraft.Vs_min**2 * aircraft.Sw 
    # L_TO = 1/2 * atm.rho0 * C_L_TO * aircraft.Vs_min**2 * aircraft.Sw 
    # M_ac_wf = 1/2*atm.rho0 * aircraft.Cm_ac_w * aircraft.Vs_min**2 * aircraft.Sw * aircraft.MAC_length

    CL_h = -1
    aircraft.L_h = 0.5 * 0.7 * CL_h * (aircraft.V_cruise)**2 * aircraft.AE_Sh_S * aircraft.Sw
    
    T= 2800 
    z_position_T = -(aircraft.ST_z_prop + aircraft.prop_radius - aircraft.ST_z_cg_ground)

    eta_h = 0.96
    V_range = np.arange(aircraft.V_s_min, aircraft.V_cruise*1.4, 2)
    
    color_r = ['black', 'steelblue']
    e = 0
    plt.figure()
    for X_cg in [aircraft.X_cg_fwd, aircraft.X_cg_aft]:
        delta_eq_req_range = []
        for V in V_range:
            l_h = aircraft.l_f - (aircraft.X_LEMAC+ X_cg*aircraft.MAC_length) + aircraft.l_f_boom - 3/4 * aircraft.AE_rootchord_h
            C_L1 = 2 * aircraft.W_TO * aircraft.g0 /(aircraft.rho_TO* V**2*aircraft.Sw)
            tail_volume = l_h/aircraft.MAC_length * aircraft.Sh_S

            C_L_delta_e = aircraft.CLa_Ah_cruise * eta_h * aircraft.Sh_S * 1
            C_m_delta_e = -aircraft.CLa_Ah_cruise *eta_h * tail_volume * 1

            delta_e_req = - ((T*z_position_T/(1/2 * aircraft.rho_TO * V**2 * aircraft.Sw * aircraft.MAC_length) + aircraft.af_cm0) * aircraft.CLa_w_cruise + (C_L1 - aircraft.af_Cl0)*aircraft.C_m_alpha)/(aircraft.CLa_w_cruise*C_m_delta_e - aircraft.C_m_alpha*C_L_delta_e)
            delta_eq_req_range.append(delta_e_req*180/np.pi)
        
        
        plt.scatter(V_range, delta_eq_req_range, marker='x', color=color_r[e])
        
        e = e +1
    
    plt.xlabel(r"V [m/s]")
    plt.ylabel(r"$\delta_E$ [deg]")

    plt.axvline(x=aircraft.V_cruise, color='red', linestyle='--')
    plt.text(aircraft.V_cruise - 2.5, min(delta_eq_req_range), r'$V_{cruise}$', rotation=90, color='red')

    plt.grid()
    plt.show(block=True)

def rudder_design(aircraft, tau_r):
    
    V_w = 20 * (0.51444444444) # [m/s] side wind

    V_t = sqrt((1.3 * aircraft.V_s_min)**2 + V_w**2) # [m/s] total speed
    S_s = 1.02 * (aircraft.l_f * aircraft.h_out + aircraft.AE_Sv_S * aircraft.Sw)

    x_ca = aircraft.l_f * aircraft.h_out * aircraft.X_FCG + aircraft.AE_S_v * aircraft.AE_l_v
    d_ca = x_ca - aircraft.x_cg_position_aft

    C_d_y = 0.6 # Assumption

    F_w = 0.5 * atm.rho0 * C_d_y * V_w**2 * S_s
    print(f"F_w:{F_w}")
    angle_beta = np.arctan(V_w/(1.3 * aircraft.V_s_min))

    C_L_alpha_v = 3
    dsigma_dalpha = 0 
    eta_v = 0.96
    
    
    vertical_tail_volume = aircraft.AE_l_v*aircraft.AE_S_v/(aircraft.b*aircraft.Sw)

    C_n_beta = 0.75 * C_L_alpha_v * (1 - dsigma_dalpha) * eta_v * vertical_tail_volume
    C_y_beta = -1.35 * C_L_alpha_v * (1 - dsigma_dalpha) * eta_v * aircraft.AE_Sv_S

    aircraft.C_r_C_v = 0.4
    # tau_r = 0.6
    C_Y_delta_r = C_L_alpha_v * eta_v * tau_r * 1 * aircraft.AE_Sv_S 
    C_n_delta_r = -C_L_alpha_v * vertical_tail_volume * eta_v * tau_r * 1

    # Define the equations
    def equations(x):
        delta_r, sigma = x
        equation1 = 0.5 * atm.rho0 * V_t**2 * aircraft.Sw * aircraft.b * (C_n_beta*(angle_beta - sigma) + C_n_delta_r * delta_r) + F_w * cos(sigma) * d_ca
        equation2 = 0.5 * atm.rho0 * V_w**2 * S_s * C_d_y - 0.5*atm.rho0 * V_t**2 * aircraft.Sw * (C_y_beta*(angle_beta-sigma)+C_Y_delta_r*delta_r)
        return [equation1, equation2]
    # Solve the system of equations
    initial_guess = [1, 1]
    solution = fsolve(equations, initial_guess)

    # Extract the values
    delta_r_value = solution[0]
    sigma_value = solution[1]
    
    aircraft.delta_r_value = delta_r_value*(180/np.pi)

    if delta_r_value*180/pi > 30:
        print(f"\nRequired rudder deflection ({round(delta_r_value, 3)} degrees) exceeds maximum rudder deflection (30 degrees)\n")

    #aircraft.S_r = aircraft.C_r_C_v * aircraft.C_v * aircraft.b_v

def rudder_iteration(aircraft):
    delta_r_value_array = []
    c_array = np.arange(0.10, 0.75, 0.05)
    tau_array = [0.27, 0.35, 0.41, 0.47, 0.52, 0.56, 0.6, 0.64, 0.68, 0.71, 0.74, 0.77, 0.8]
    plt.figure()
    for i in tau_array:
        tau_r = i
        rudder_design(aircraft, tau_r)

        delta_r_value_array.append(aircraft.delta_r_value)

    
    plt.scatter(c_array, delta_r_value_array, marker='x', color='black')
    plt.axhline(y=30, color= 'red')
    plt.text(0.6, 30.5, r"$\delta_{r_{max}}$", rotation=0, color='red')
    plt.axhline(y=27, color= 'darkorange')
    plt.text(0.6, 27.5, r"$\delta_{r_{max}}$ + margin", rotation=0, color='red')

    index = np.where(np.array(delta_r_value_array) < 27)[0][0]
    plt.scatter(c_array[index], delta_r_value_array[index], color='r')


    plt.xlabel(r"$\frac{C_r}{C_v}$")
    plt.ylabel(r"$\delta_{r_{max}}$ [deg]")
    plt.show(block=True)
def main_control_surface(aircraft):
    aileron_design(aircraft)
    rudder_iteration(aircraft)
    # rudder_design(aircraft)
    elevator_design(aircraft)